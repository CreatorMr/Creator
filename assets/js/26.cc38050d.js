(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{604:function(e,t,n){"use strict";n.r(t);var a=n(4),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Set 和 Map 主要的应用场景在于 数据重组 和 数据储存\nSet 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构")]),e._v(" "),n("ol",[n("li",[e._v("集合（Set）\nES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。\nSet 本身是一种构造函数，用来生成 Set 数据结构。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("new Set([iterable])\n")])])]),n("p",[e._v("举个例子：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const s = new Set()\n[1, 2, 3, 4, 3, 2, 1].forEach(x => s.add(x))\n\nfor (let i of s) {\n    console.log(i)\t// 1 2 3 4\n}\n\n// 去重数组的重复对象\nlet arr = [1, 2, 3, 2, 1, 1]\n[... new Set(arr)]\t// [1, 2, 3]\n")])])]),n("p",[e._v("Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。")]),e._v(" "),n("p",[e._v('向 Set 加入值的时候，不会发生类型转换，所以5和"5"是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是** Set 认为NaN等于自身，而精确相等运算符认为NaN不等于自身。**')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let set = new Set();\nlet a = NaN;\nlet b = NaN;\nset.add(a);\nset.add(b);\nset // Set {NaN}\n\nlet set1 = new Set()\nset1.add(5)\nset1.add('5')\nconsole.log([...set1])\t// [5, \"5\"]\n")])])]),n("p",[e._v("Set 实例属性")]),e._v(" "),n("p",[e._v("constructor： 构造函数")]),e._v(" "),n("p",[e._v("size：元素数量")]),e._v(" "),n("p",[e._v("let set = new Set([1, 2, 3, 2, 1])")]),e._v(" "),n("p",[e._v("console.log(set.length)\t// undefined\nconsole.log(set.size)\t// 3\nSet 实例方法")]),e._v(" "),n("p",[e._v("操作方法\nadd(value)：新增，相当于 array里的push")]),e._v(" "),n("p",[e._v("delete(value)：存在即删除集合中value")]),e._v(" "),n("p",[e._v("has(value)：判断集合中是否存在 value")]),e._v(" "),n("p",[e._v("clear()：清空集合")]),e._v(" "),n("p",[e._v("let set = new Set()\nset.add(1).add(2).add(1)")]),e._v(" "),n("p",[e._v("set.has(1)\t// true\nset.has(3)\t// false\nset.delete(1)\t\nset.has(1)\t// false\nArray.from 方法可以将 Set 结构转为数组")]),e._v(" "),n("p",[e._v("const items = new Set([1, 2, 3, 2])\nconst array = Array.from(items)\nconsole.log(array)\t// [1, 2, 3]\n// 或\nconst arr = [...items]\nconsole.log(arr)\t// [1, 2, 3]\n遍历方法（遍历顺序为插入顺序）\nkeys()：返回一个包含集合中所有键的迭代器")]),e._v(" "),n("p",[e._v("values()：返回一个包含集合中所有值得迭代器")]),e._v(" "),n("p",[e._v("entries()：返回一个包含Set对象中所有元素得键值对迭代器")]),e._v(" "),n("p",[e._v("forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，没有返回值")]),e._v(" "),n("p",[e._v("let set = new Set([1, 2, 3])\nconsole.log(set.keys())\t// SetIterator {1, 2, 3}\nconsole.log(set.values())\t// SetIterator {1, 2, 3}\nconsole.log(set.entries())\t// SetIterator {1, 2, 3}")]),e._v(" "),n("p",[e._v("for (let item of set.keys()) {\nconsole.log(item);\n}\t// 1\t2\t 3\nfor (let item of set.entries()) {\nconsole.log(item);\n}\t// [1, 1]\t[2, 2]\t[3, 3]")]),e._v(" "),n("p",[e._v("set.forEach((value, key) =>  {\nconsole.log(key + ' : ' + value)\n})\t// 1 : 1\t2 : 2\t\t3 : 3\nconsole.log([...set])\t// [1, 2, 3]\nSet 可默认遍历，默认迭代器生成函数是 values() 方法")]),e._v(" "),n("p",[e._v("Set.prototype[Symbol.iterator] === Set.prototype.values\t// true\n所以， Set可以使用 map、filter 方法")]),e._v(" "),n("p",[e._v("let set = new Set([1, 2, 3])\nset = new Set([...set].map(item => item * 2))\nconsole.log([...set])\t// [2, 4, 6]")]),e._v(" "),n("p",[e._v("set = new Set([...set].filter(item => (item >= 4)))\nconsole.log([...set])\t//[4, 6]\n因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）")]),e._v(" "),n("p",[e._v("let set1 = new Set([1, 2, 3])\nlet set2 = new Set([4, 3, 2])")]),e._v(" "),n("p",[e._v("let intersect = new Set([...set1].filter(value => set2.has(value)))\nlet union = new Set([...set1, ...set2])\nlet difference = new Set([...set1].filter(value => !set2.has(value)))")]),e._v(" "),n("p",[e._v("console.log(intersect)\t// Set {2, 3}\nconsole.log(union)\t\t// Set {1, 2, 3, 4}\nconsole.log(difference)\t// Set {1}\n2. WeakSet\nWeakSet 对象允许你将弱引用对象储存在一个集合中")]),e._v(" "),n("p",[e._v("WeakSet 与 Set 的区别：")]),e._v(" "),n("p",[e._v("WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以\nWeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素\n属性：")]),e._v(" "),n("p",[e._v("constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数")]),e._v(" "),n("p",[e._v("const arr = [[1, 2], [3, 4]]\nconst weakset = new WeakSet(arr)\nconsole.log(weakset)\n2019-03-08 9 24 34")]),e._v(" "),n("p",[e._v("方法：")]),e._v(" "),n("p",[e._v("add(value)：在WeakSet 对象中添加一个元素value\nhas(value)：判断 WeakSet 对象中是否包含value\ndelete(value)：删除元素 value\nclear()：清空所有元素，注意该方法已废弃\nvar ws = new WeakSet()\nvar obj = {}\nvar foo = {}")]),e._v(" "),n("p",[e._v("ws.add(window)\nws.add(obj)")]),e._v(" "),n("p",[e._v("ws.has(window)\t// true\nws.has(foo)\t// false")]),e._v(" "),n("p",[e._v("ws.delete(window)\t// true\nws.has(window)\t// false\n3. 字典（Map）\n集合 与 字典 的区别：")]),e._v(" "),n("p",[e._v("共同点：集合、字典 可以储存不重复的值\n不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存\nconst m = new Map()\nconst o = {p: 'haha'}\nm.set(o, 'content')\nm.get(o)\t// content")]),e._v(" "),n("p",[e._v("m.has(o)\t// true\nm.delete(o)\t// true\nm.has(o)\t// false\n任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构都可以当作Map构造函数的参数，例如：")]),e._v(" "),n("p",[e._v("const set = new Set([\n['foo', 1],\n['bar', 2]\n]);\nconst m1 = new Map(set);\nm1.get('foo') // 1")]),e._v(" "),n("p",[e._v("const m2 = new Map([['baz', 3]]);\nconst m3 = new Map(m2);\nm3.get('baz') // 3\n如果读取一个未知的键，则返回undefined。")]),e._v(" "),n("p",[e._v("new Map().get('asfddfsasadf')\n// undefined\n注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。")]),e._v(" "),n("p",[e._v("const map = new Map();")]),e._v(" "),n("p",[e._v("map.set(['a'], 555);\nmap.get(['a']) // undefined\n上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。")]),e._v(" "),n("p",[e._v("由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。")]),e._v(" "),n("p",[e._v("如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。")]),e._v(" "),n("p",[e._v("let map = new Map();")]),e._v(" "),n("p",[e._v("map.set(-0, 123);\nmap.get(+0) // 123")]),e._v(" "),n("p",[e._v("map.set(true, 1);\nmap.set('true', 2);\nmap.get(true) // 1")]),e._v(" "),n("p",[e._v("map.set(undefined, 3);\nmap.set(null, 4);\nmap.get(undefined) // 3")]),e._v(" "),n("p",[e._v("map.set(NaN, 123);\nmap.get(NaN) // 123\nMap 的属性及方法")]),e._v(" "),n("p",[e._v("属性：")]),e._v(" "),n("p",[e._v("constructor：构造函数")]),e._v(" "),n("p",[e._v("size：返回字典中所包含的元素个数")]),e._v(" "),n("p",[e._v("const map = new Map([\n['name', 'An'],\n['des', 'JS']\n]);")]),e._v(" "),n("p",[e._v("map.size // 2\n操作方法：")]),e._v(" "),n("p",[e._v("set(key, value)：向字典中添加新元素\nget(key)：通过键查找特定的数值并返回\nhas(key)：判断字典中是否存在键key\ndelete(key)：通过键 key 从字典中移除对应的数据\nclear()：将这个字典中的所有元素删除\n遍历方法")]),e._v(" "),n("p",[e._v('Keys()：将字典中包含的所有键名以迭代器形式返回\nvalues()：将字典中包含的所有数值以迭代器形式返回\nentries()：返回所有成员的迭代器\nforEach()：遍历字典的所有成员\nconst map = new Map([\n[\'name\', \'An\'],\n[\'des\', \'JS\']\n]);\nconsole.log(map.entries())\t// MapIterator {"name" => "An", "des" => "JS"}\nconsole.log(map.keys()) // MapIterator {"name", "des"}\nMap 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。')]),e._v(" "),n("p",[e._v("map[Symbol.iterator] === map.entries\n// true\nMap 结构转为数组结构，比较快速的方法是使用扩展运算符（...）。")]),e._v(" "),n("p",[e._v("对于 forEach ，看一个例子")]),e._v(" "),n("p",[e._v('const reporter = {\nreport: function(key, value) {\nconsole.log("Key: %s, Value: %s", key, value);\n}\n};')]),e._v(" "),n("p",[e._v("let map = new Map([\n['name', 'An'],\n['des', 'JS']\n])\nmap.forEach(function(value, key, map) {\nthis.report(key, value);\n}, reporter);\n// Key: name, Value: An\n// Key: des, Value: JS\n在这个例子中， forEach 方法的回调函数的 this，就指向 reporter")]),e._v(" "),n("p",[e._v("与其他数据结构的相互转换")]),e._v(" "),n("p",[e._v("Map 转 Array")]),e._v(" "),n("p",[e._v("const map = new Map([[1, 1], [2, 2], [3, 3]])\nconsole.log([...map])\t// [[1, 1], [2, 2], [3, 3]]\nArray 转 Map")]),e._v(" "),n("p",[e._v("const map = new Map([[1, 1], [2, 2], [3, 3]])\nconsole.log(map)\t// Map {1 => 1, 2 => 2, 3 => 3}\nMap 转 Object")]),e._v(" "),n("p",[e._v("因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。")]),e._v(" "),n("p",[e._v("function mapToObj(map) {\nlet obj = Object.create(null)\nfor (let [key, value] of map) {\nobj[key] = value\n}\nreturn obj\n}\nconst map = new Map().set('name', 'An').set('des', 'JS')\nmapToObj(map) // {name: \"An\", des: \"JS\"}\nObject 转 Map")]),e._v(" "),n("p",[e._v("function objToMap(obj) {\nlet map = new Map()\nfor (let key of Object.keys(obj)) {\nmap.set(key, obj[key])\n}\nreturn map\n}")]),e._v(" "),n("p",[e._v("objToMap({'name': 'An', 'des': 'JS'}) // Map {\"name\" => \"An\", \"des\" => \"JS\"}\nMap 转 JSON")]),e._v(" "),n("p",[e._v("function mapToJson(map) {\nreturn JSON.stringify([...map])\n}")]),e._v(" "),n("p",[e._v("let map = new Map().set('name', 'An').set('des', 'JS')\nmapToJson(map)\t// [[\"name\",\"An\"],[\"des\",\"JS\"]]\nJSON 转 Map")]),e._v(" "),n("p",[e._v("function jsonToStrMap(jsonStr) {\nreturn objToMap(JSON.parse(jsonStr));\n}")]),e._v(" "),n("p",[e._v('jsonToStrMap(\'{"name": "An", "des": "JS"}\') // Map {"name" => "An", "des" => "JS"}\n4. WeakMap\nWeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。')]),e._v(" "),n("p",[e._v("注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。")]),e._v(" "),n("p",[e._v("WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。")]),e._v(" "),n("p",[e._v("属性：")]),e._v(" "),n("p",[e._v("constructor：构造函数\n方法：")]),e._v(" "),n("p",[e._v("has(key)：判断是否有 key 关联对象\nget(key)：返回key关联对象（没有则则返回 undefined）\nset(key)：设置一组key关联对象\ndelete(key)：移除 key 的关联对象\nlet myElement = document.getElementById('logo');\nlet myWeakmap = new WeakMap();")]),e._v(" "),n("p",[e._v("myWeakmap.set(myElement, {timesClicked: 0});")]),e._v(" "),n("p",[e._v("myElement.addEventListener('click', function() {\nlet logoData = myWeakmap.get(myElement);\nlogoData.timesClicked++;\n}, false);\n5. 总结\nSet\n成员唯一、无序且不重复\n[value, value]，键值与键名是一致的（或者说只有键值，没有键名）\n可以遍历，方法有：add、delete、has\nWeakSet\n成员都是对象\n成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏\n不能遍历，方法有add、delete、has\nMap\n本质上是键值对的集合，类似集合\n可以遍历，方法很多可以跟各种数据格式转换\nWeakMap\n只接受对象作为键名（null除外），不接受其他类型的值作为键名\n键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的\n不能遍历，方法有get、set、has、delete\n6. 扩展：Object与Set、Map\nObject 与 Set")]),e._v(" "),n("p",[e._v("// Object\nconst properties1 = {\n'width': 1,\n'height': 1\n}\nconsole.log(properties1['width']? true: false) // true")]),e._v(" "),n("p",[e._v("// Set\nconst properties2 = new Set()\nproperties2.add('width')\nproperties2.add('height')\nconsole.log(properties2.has('width')) // true\nObject 与 Map")]),e._v(" "),n("p",[e._v("JS 中的对象（Object），本质上是键值对的集合（hash 结构）")]),e._v(" "),n("p",[e._v("const data = {};\nconst element = document.getElementsByClassName('App');")]),e._v(" "),n("p",[e._v("data[element] = 'metadata';\nconsole.log(data['[object HTMLCollection]']) // \"metadata\"\n但当以一个DOM节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 字符串-值 对应，Map则提供了 值-值 的对应")])])}),[],!1,null,null,null);t.default=s.exports}}]);